package exploit

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/saixpereos-debug/parashu/pkg/output"
	"github.com/saixpereos-debug/parashu/pkg/vuln"
)

type ExploitMatcher struct {
	db *vuln.DB
}

func NewExploitMatcher(database *vuln.DB) *ExploitMatcher {
	return &ExploitMatcher{
		db: database,
	}
}

func (em *ExploitMatcher) MatchExploits(hostRes output.HostResult) ([]vuln.PrioritizedExploit, error) {
	var allMatches []vuln.ExploitMatch

	for _, port := range hostRes.Ports {
		// Match by CVE
		if port.CPE != "" {
			// This is a simplification; a real engine would map CPE -> CVE first,
			// but we can also match exploits directly by CPE or keywords in title.

			// For now, let's assume we have CVEs in port results if found
			// (Parashu's scanner should eventually populate this).
		}

		// Example: Search by Service and Banner
		if port.Service != "" {
			query := port.Service
			exploits, err := em.db.SearchExploits(query)
			if err == nil {
				for _, e := range exploits {
					allMatches = append(allMatches, vuln.ExploitMatch{
						ExploitID:  e.ID,
						Confidence: 60,
						MatchType:  "service",
						Evidence:   fmt.Sprintf("Service name '%s' matches exploit title/description", port.Service),
					})
				}
			}
		}

		// Match by Banner keywords
		if port.Banner != "" {
			bannerMatches := em.matchByBanner(port.Banner)
			allMatches = append(allMatches, bannerMatches...)
		}
	}

	// De-duplicate and Prioritize
	return em.prioritize(allMatches), nil
}

func (em *ExploitMatcher) matchByBanner(banner string) []vuln.ExploitMatch {
	var matches []vuln.ExploitMatch
	// Simple keyword extraction for matching
	keywords := strings.Fields(strings.ToLower(banner))
	for _, kw := range keywords {
		if len(kw) < 4 {
			continue
		}
		exploits, err := em.db.SearchExploits(kw)
		if err == nil {
			for _, e := range exploits {
				matches = append(matches, vuln.ExploitMatch{
					ExploitID:  e.ID,
					Confidence: 50,
					MatchType:  "banner",
					Evidence:   fmt.Sprintf("Banner keyword '%s' found in exploit metadata", kw),
				})
			}
		}
	}
	return matches
}

func (em *ExploitMatcher) prioritize(matches []vuln.ExploitMatch) []vuln.PrioritizedExploit {
	uniqueMatches := make(map[int]vuln.ExploitMatch)
	for _, m := range matches {
		if existing, ok := uniqueMatches[m.ExploitID]; !ok || m.Confidence > existing.Confidence {
			uniqueMatches[m.ExploitID] = m
		}
	}

	var result []vuln.PrioritizedExploit
	for id, m := range uniqueMatches {
		exploit, err := em.db.GetExploit(id)
		if err != nil {
			continue
		}

		score := m.Confidence
		if exploit.Verified {
			score += 10
		}
		if exploit.Metasploit {
			score += 20
		}
		if time.Since(exploit.Date) < 2*365*24*time.Hour {
			score += 5
		}

		result = append(result, vuln.PrioritizedExploit{
			Exploit:  *exploit,
			Match:    m,
			Priority: score,
		})
	}

	sort.Slice(result, func(i, j int) bool {
		return result[i].Priority > result[j].Priority
	})

	return result
}
