package exploit

import (
	"archive/zip"
	"bytes"
	"encoding/csv"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/saixpereos-debug/parashu/pkg/vuln"
)

type ExploitSync struct {
	db      *vuln.DB
	dataDir string
}

func NewExploitSync(database *vuln.DB, dataDir string) *ExploitSync {
	return &ExploitSync{
		db:      database,
		dataDir: dataDir,
	}
}

func (es *ExploitSync) SyncAll() error {
	fmt.Println("[+] Starting exploit database synchronization...")

	// Sync Exploit-DB
	if err := es.SyncExploitDB(); err != nil {
		return fmt.Errorf("failed to sync Exploit-DB: %v", err)
	}

	// Stubs for future integrations
	es.SyncVulners()
	es.SyncGitHubAdvisories()
	es.SyncOSV()

	fmt.Println("[+] Exploit database synchronization completed")
	return nil
}

func (es *ExploitSync) SyncExploitDB() error {
	fmt.Println("[*] Syncing Exploit-DB...")

	exploitDir := filepath.Join(es.dataDir, "exploits")
	if err := os.MkdirAll(exploitDir, 0755); err != nil {
		return err
	}

	// Download Exploit-DB archive (using a stable GitLab link)
	url := "https://gitlab.com/exploit-database/exploitdb/-/archive/main/exploitdb-main.zip"
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download Exploit-DB: HTTP %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}

	zipReader, err := zip.NewReader(bytes.NewReader(body), int64(len(body)))
	if err != nil {
		return err
	}

	var filesCSV *zip.File
	for _, file := range zipReader.File {
		if strings.HasSuffix(file.Name, "files_exploits.csv") {
			filesCSV = file
			break
		}
	}

	if filesCSV == nil {
		return fmt.Errorf("files_exploits.csv not found in archive")
	}

	rc, err := filesCSV.Open()
	if err != nil {
		return err
	}
	defer rc.Close()

	reader := csv.NewReader(rc)
	// Skip header
	_, _ = reader.Read()

	count := 0
	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			continue
		}

		if len(record) < 13 {
			continue
		}

		edbID, _ := strconv.Atoi(record[0])
		date, _ := time.Parse("2006-01-02", record[3])
		port, _ := strconv.Atoi(record[7])
		verified := (record[10] == "1")

		// Extract CVEs from codes column (record[11])
		// Format: CVE-2009-3699;OSVDB-58726
		var cves []string
		codes := strings.Split(record[11], ";")
		for _, code := range codes {
			if strings.HasPrefix(strings.ToUpper(code), "CVE-") {
				cves = append(cves, strings.TrimSpace(code))
			}
		}

		// Heuristic for Metasploit
		isMetasploit := strings.Contains(strings.ToLower(record[2]), "metasploit") ||
			strings.Contains(strings.ToLower(record[12]), "metasploit") ||
			strings.Contains(strings.ToLower(record[12]), "msf")

		exploit := vuln.Exploit{
			EDBID:       edbID,
			CodePath:    record[1],
			Title:       record[2],
			Date:        date,
			Author:      record[4],
			Type:        record[5],
			Platform:    record[6],
			Port:        port,
			Verified:    verified,
			Description: record[2],
			CVEs:        cves,
			Metasploit:  isMetasploit,
		}

		if err := es.db.InsertExploit(exploit); err == nil {
			count++
		}
	}

	fmt.Printf("[+] Imported %d exploits from Exploit-DB\n", count)
	return nil
}

func (es *ExploitSync) SyncVulners() {
	fmt.Println("[*] Syncing Vulners database (Stub)...")
}

func (es *ExploitSync) SyncGitHubAdvisories() {
	fmt.Println("[*] Syncing GitHub Advisory Database (Stub)...")
}

func (es *ExploitSync) SyncOSV() {
	fmt.Println("[*] Syncing OSV.dev database (Stub)...")
}
